// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
import { __assign, __awaiter, __extends, __generator, __spreadArrays } from "tslib";
import { BaseRequestPolicy } from "@azure/core-http";
import { Constants } from "@azure/core-http";
import { ExpiringAccessTokenCache } from "@azure/core-http";
/**
 * Representation of the Authentication Challenge
 */
var AuthenticationChallenge = /** @class */ (function () {
    function AuthenticationChallenge(authorization, scope) {
        this.authorization = authorization;
        this.scope = scope;
    }
    /**
     * Checks that this AuthenticationChallenge is equal to another one given.
     * Only compares the scope.
     * This is exactly what C# is doing, as we can see here:
     * https://github.com/Azure/azure-sdk-for-net/blob/70e54b878ff1d01a45266fb3674a396b4ab9c1d2/sdk/keyvault/Azure.Security.KeyVault.Shared/src/ChallengeBasedAuthenticationPolicy.cs#L143-L147
     * @param other The other AuthenticationChallenge
     */
    AuthenticationChallenge.prototype.equalTo = function (other) {
        return other
            ? this.scope.toLowerCase() === other.scope.toLowerCase() &&
                this.authorization.toLowerCase() === other.authorization.toLowerCase()
            : false;
    };
    return AuthenticationChallenge;
}());
export { AuthenticationChallenge };
/**
 * Helps keep a copy of any previous authentication challenges,
 * so that we can compare on any further request.
 */
var AuthenticationChallengeCache = /** @class */ (function () {
    function AuthenticationChallengeCache() {
    }
    AuthenticationChallengeCache.prototype.setCachedChallenge = function (challenge) {
        this.challenge = challenge;
    };
    return AuthenticationChallengeCache;
}());
export { AuthenticationChallengeCache };
/**
 * Creates a new ChallengeBasedAuthenticationPolicy factory.
 *
 * @param credential The TokenCredential implementation that can supply the challenge token.
 */
export function challengeBasedAuthenticationPolicy(credential) {
    var tokenCache = new ExpiringAccessTokenCache();
    var challengeCache = new AuthenticationChallengeCache();
    return {
        create: function (nextPolicy, options) {
            return new ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential, tokenCache, challengeCache);
        }
    };
}
/**
 * Parses an WWW-Authenticate response.
 * This transforms a string value like:
 * `Bearer authorization="some_authorization", resource="https://some.url"`
 * into an object like:
 * `{ authorization: "some_authorization", resource: "https://some.url" }`
 * @param wwwAuthenticate string value in the WWW-Authenticate header
 */
export function parseWWWAuthenticate(wwwAuthenticate) {
    // First we split the string by either `, ` or ` `.
    var parts = wwwAuthenticate.split(/,* +/);
    // Then we only keep the strings with an equal sign after a word and before a quote.
    // also splitting these sections by their equal sign
    var keyValues = parts.reduce(function (parts, str) { return (str.match(/\w="/) ? __spreadArrays(parts, [str.split("=")]) : parts); }, []);
    // Then we transform these key-value pairs back into an object.
    var parsed = keyValues.reduce(function (result, _a) {
        var _b;
        var key = _a[0], value = _a[1];
        return (__assign(__assign({}, result), (_b = {}, _b[key] = value.slice(1, -1), _b)));
    }, {});
    return parsed;
}
/**
 *
 * Provides a RequestPolicy that can request a token from a TokenCredential
 * implementation and then apply it to the Authorization header of a request
 * as a Bearer token.
 *
 */
var ChallengeBasedAuthenticationPolicy = /** @class */ (function (_super) {
    __extends(ChallengeBasedAuthenticationPolicy, _super);
    /**
     * Creates a new ChallengeBasedAuthenticationPolicy object.
     *
     * @param nextPolicy The next RequestPolicy in the request pipeline.
     * @param options Options for this RequestPolicy.
     * @param credential The TokenCredential implementation that can supply the bearer token.
     * @param tokenCache The cache for the most recent AccessToken returned by the TokenCredential.
     */
    function ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential, tokenCache, challengeCache) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.credential = credential;
        _this.tokenCache = tokenCache;
        _this.challengeCache = challengeCache;
        _this.parseWWWAuthenticate = parseWWWAuthenticate;
        return _this;
    }
    /**
     * Gets or updates the token from the token cache into the headers of the received web resource.
     */
    ChallengeBasedAuthenticationPolicy.prototype.loadToken = function (webResource) {
        return __awaiter(this, void 0, void 0, function () {
            var accessToken, receivedToken;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        accessToken = this.tokenCache.getCachedToken();
                        if (!(accessToken === undefined)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.credential.getToken(this.challengeCache.challenge.scope)];
                    case 1:
                        receivedToken = _a.sent();
                        accessToken = receivedToken || undefined;
                        this.tokenCache.setCachedToken(accessToken);
                        _a.label = 2;
                    case 2:
                        if (accessToken) {
                            webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, "Bearer " + accessToken.token);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Parses the given WWW-Authenticate header, generates a new AuthenticationChallenge,
     * then if the challenge is different from the one cached, resets the token and forces
     * a re-authentication, otherwise continues with the existing challenge and token.
     * @param wwwAuthenticate Value of the incoming WWW-Authenticate header.
     * @param webResource Ongoing HTTP request.
     */
    ChallengeBasedAuthenticationPolicy.prototype.regenerateChallenge = function (wwwAuthenticate, webResource) {
        return __awaiter(this, void 0, void 0, function () {
            var parsedWWWAuth, authorization, resource, challenge;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        parsedWWWAuth = this.parseWWWAuthenticate(wwwAuthenticate);
                        authorization = parsedWWWAuth.authorization;
                        resource = parsedWWWAuth.resource || parsedWWWAuth.scope;
                        if (!(authorization && resource)) {
                            return [2 /*return*/, this._nextPolicy.sendRequest(webResource)];
                        }
                        challenge = new AuthenticationChallenge(authorization, resource + "/.default");
                        // Either if there's no cached challenge at this point (could have happen in parallel),
                        // or if the cached challenge has a different scope,
                        // we store the just received challenge and reset the cached token, to force a re-authentication.
                        if (!(this.challengeCache.challenge && this.challengeCache.challenge.equalTo(challenge))) {
                            this.challengeCache.setCachedChallenge(challenge);
                            this.tokenCache.setCachedToken(undefined);
                        }
                        return [4 /*yield*/, this.loadToken(webResource)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this._nextPolicy.sendRequest(webResource)];
                }
            });
        });
    };
    /**
     * Applies the Bearer token to the request through the Authorization header.
     * @param webResource Ongoing HTTP request.
     */
    ChallengeBasedAuthenticationPolicy.prototype.sendRequest = function (webResource) {
        return __awaiter(this, void 0, void 0, function () {
            var response, originalBody, wwwAuthenticate;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Ensure that we're about to use a secure connection.
                        if (!webResource.url.startsWith("https:")) {
                            throw new Error("The resource address for authorization must use the 'https' protocol.");
                        }
                        if (!(this.challengeCache.challenge == undefined)) return [3 /*break*/, 2];
                        originalBody = webResource.body;
                        webResource.body = "";
                        return [4 /*yield*/, this._nextPolicy.sendRequest(webResource)];
                    case 1:
                        response = _a.sent();
                        webResource.body = originalBody;
                        return [3 /*break*/, 5];
                    case 2: 
                    // If we did have a challenge in memory,
                    // we attempt to load the token from the cache into the request before we try to send the request.
                    return [4 /*yield*/, this.loadToken(webResource)];
                    case 3:
                        // If we did have a challenge in memory,
                        // we attempt to load the token from the cache into the request before we try to send the request.
                        _a.sent();
                        return [4 /*yield*/, this._nextPolicy.sendRequest(webResource)];
                    case 4:
                        response = _a.sent();
                        _a.label = 5;
                    case 5:
                        // If we don't receive a response with a 401 status code,
                        // then we can assume this response has nothing to do with the challenge authentication process.
                        if (response.status !== 401) {
                            return [2 /*return*/, response];
                        }
                        wwwAuthenticate = response.headers.get("WWW-Authenticate");
                        if (!wwwAuthenticate) {
                            return [2 /*return*/, response];
                        }
                        return [4 /*yield*/, this.regenerateChallenge(wwwAuthenticate, webResource)];
                    case 6: 
                    // We re-generate the challenge and see if we have to re-authenticate.
                    return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return ChallengeBasedAuthenticationPolicy;
}(BaseRequestPolicy));
export { ChallengeBasedAuthenticationPolicy };
//# sourceMappingURL=challengeBasedAuthenticationPolicy.js.map