// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter, __generator } from "tslib";
import * as assert from "assert";
import { env } from "@azure/test-utils-recorder";
import { authenticate } from "./utils/testAuthentication";
import { AuthenticationChallengeCache, AuthenticationChallenge, parseWWWAuthenticate } from "../src/core/challengeBasedAuthenticationPolicy";
import { createSandbox } from "sinon";
// Following the philosophy of not testing the insides if we can test the outsides...
// I present you with this "Get Out of Jail Free" card (in reference to Monopoly).
// Once we move to a common folder, and after some refactoring,
// we will be able to unit test the insides in detail.
describe("Challenge based authentication tests", function () {
    var secretPrefix = "challengeAuth" + (env.KEY_NAME || "SecretName");
    var secretSuffix;
    var client;
    var testClient;
    var recorder;
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function () {
            var authentication;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        secretSuffix = authentication.secretSuffix;
                        client = authentication.client;
                        testClient = authentication.testClient;
                        recorder = authentication.recorder;
                        return [2 /*return*/];
                }
            });
        });
    });
    afterEach(function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                recorder.stop();
                return [2 /*return*/];
            });
        });
    });
    // The tests follow
    it("Once authenticated, new requests should not authenticate again", function () {
        return __awaiter(this, void 0, void 0, function () {
            var sandbox, spy, secretName, secretNames, _i, secretNames_1, name_1, _a, secretNames_2, name_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        sandbox = createSandbox();
                        spy = sandbox.spy(AuthenticationChallengeCache.prototype, "setCachedChallenge");
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretNames = [secretName + "-0", secretName + "-1"];
                        _i = 0, secretNames_1 = secretNames;
                        _b.label = 1;
                    case 1:
                        if (!(_i < secretNames_1.length)) return [3 /*break*/, 4];
                        name_1 = secretNames_1[_i];
                        return [4 /*yield*/, client.setSecret(name_1, "value")];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        _a = 0, secretNames_2 = secretNames;
                        _b.label = 5;
                    case 5:
                        if (!(_a < secretNames_2.length)) return [3 /*break*/, 8];
                        name_2 = secretNames_2[_a];
                        return [4 /*yield*/, testClient.flushSecret(name_2)];
                    case 6:
                        _b.sent();
                        _b.label = 7;
                    case 7:
                        _a++;
                        return [3 /*break*/, 5];
                    case 8:
                        // The challenge should have been written to the cache exactly ONCE.
                        assert.equal(spy.getCalls().length, 1);
                        // Back to normal.
                        sandbox.restore();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("Authentication should work for parallel requests", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, secretNames, sandbox, spy, spyEqualTo, promises, _i, promises_1, promise;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretNames = [secretName + "-0", secretName + "-1"];
                        sandbox = createSandbox();
                        spy = sandbox.spy(AuthenticationChallengeCache.prototype, "setCachedChallenge");
                        spyEqualTo = sandbox.spy(AuthenticationChallenge.prototype, "equalTo");
                        promises = secretNames.map(function (name) {
                            var promise = client.setSecret(name, "value");
                            return { promise: promise, name: name };
                        });
                        _i = 0, promises_1 = promises;
                        _a.label = 1;
                    case 1:
                        if (!(_i < promises_1.length)) return [3 /*break*/, 5];
                        promise = promises_1[_i];
                        return [4 /*yield*/, promise.promise];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, testClient.flushSecret(promise.name)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 1];
                    case 5:
                        // Even though we had parallel requests, only one authentication should have happened.
                        // This is determined by the comparison between the cached challenge and the new receive challenge.
                        // So, AuthenticationChallenge's equalTo should have returned true at least once.
                        assert.ok(spyEqualTo.returned(true));
                        // The challenge should have been written to the cache exactly ONCE.
                        assert.equal(spy.getCalls().length, 1);
                        // Back to normal.
                        sandbox.restore();
                        return [2 /*return*/];
                }
            });
        });
    });
    describe("parseWWWAuthenticate tests", function () {
        it("Should work for known shapes of the WWW-Authenticate header", function () {
            var wwwAuthenticate1 = "Bearer authorization=\"some_authorization\", resource=\"https://some.url\"";
            var parsed1 = parseWWWAuthenticate(wwwAuthenticate1);
            assert.deepEqual(parsed1, {
                authorization: "some_authorization",
                resource: "https://some.url"
            });
            var wwwAuthenticate2 = "Bearer authorization=\"some_authorization\", scope=\"https://some.url\"";
            var parsed2 = parseWWWAuthenticate(wwwAuthenticate2);
            assert.deepEqual(parsed2, {
                authorization: "some_authorization",
                scope: "https://some.url"
            });
        });
        it("Should skip unexpected properties on the WWW-Authenticate header", function () {
            var wwwAuthenticate1 = "Bearer authorization=\"some_authorization\", a=\"a\", b=\"b\"";
            var parsed1 = parseWWWAuthenticate(wwwAuthenticate1);
            assert.deepEqual(parsed1, {
                authorization: "some_authorization",
                a: "a",
                b: "b"
            });
            var wwwAuthenticate2 = "scope=\"https://some.url\", a=\"a\", c=\"c\"";
            var parsed2 = parseWWWAuthenticate(wwwAuthenticate2);
            assert.deepEqual(parsed2, {
                scope: "https://some.url",
                a: "a",
                c: "c"
            });
        });
    });
});
//# sourceMappingURL=challengeBasedAuthenticationPolicy.test.js.map